import netmiko
import paramiko
from nameko.rpc import rpc, RpcProxy


class SSH:
    """
        SSH Connector Service
        Function that performs the application via ssh of the rules generated by the translation modules
        Receive parameters:
          - host: management ip of the device that will receive the rules
          - port: device ssh port
          - username: device username for ssh access
          - password: device password for ssh access
          - device_type: indicates the device's OS 'cisco_ios' or 'linux', other devices_type are available
          in the netmiko documentation
          - command: set of commands generated by the translator module
        Return:
          - String 'ERROR': if an error is identified in the application of the rules
          - String 'OK': successful application of the rules
    """

    name = "ssh_connector"
    zipcode_rpc = RpcProxy('ssh_service_connector')

    @rpc
    def apply_config(self, host, port, username, password, device_type, commands):
        with open('command.txt', 'w+b') as archive:
            archive.write(commands.encode())
        archive = open('command.txt', 'r')
        try:
            ssh_session = netmiko.ConnectHandler(device_type=device_type, ip=host, port=port, username=username, password=password)
            if device_type == 'cisco_ios':
                ssh_session.send_command_expect("enable" + '\n', expect_string="Password: ")
                ssh_session.send_command_expect(password + '\n', expect_string="# ")
            elif device_type == 'linux':
                ssh_session.send_command_expect("sudo su" + '\n', expect_string=": ")
                ssh_session.send_command_expect(password + '\n', expect_string="# ")
            for line in archive:
                print('Linha: ' + line)
                output = ssh_session.send_command(line + '\n', expect_string="#", cmd_verify=False)
                #if 'error' or 'warning' in output.lower():
                #    return 'ERROR'
                print('Retorno: ' + output)
            if device_type == 'cisco_ios':
                ssh_session.send_command("exit" + '\n', expect_string='Logoff', cmd_verify=False)
            elif device_type == 'linux':
                ssh_session.send_command("exit" + '\n', expect_string='$', cmd_verify=False)
                ssh_session.send_command("exit" + '\n', expect_string='sair', cmd_verify=False)
            ssh_session.disconnect()
            return 'OK'
        except(netmiko.ssh_exception.NetMikoAuthenticationException,
               netmiko.ssh_exception.NetMikoTimeoutException,
               paramiko.ssh_exception.SSHException) as s_error:
            print(s_error)


#if __name__ == '__main__':
#    ssh = SSH()
#    var = """iptables -A FORWARD -s 10.12.0.0/255.255.255.0 -d 8.8.8.8 -p tcp --dport 443 -j ACCEPT"""
#    ssh.apply_config('10.12.0.121', '22', 'iptables', 'iptables', 'linux', var)



